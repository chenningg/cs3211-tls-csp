#import "PAT.Lib.RandomNumber";

enum{
	DHE,
	Hello
};


// Define number of clients
#define NoOfClients 1;

// Define ciper suite (we only use DHE)
var cipherSuite = DHE;

// Define p and g variables for all clients
var p[NoOfClients]; // p[clientID] = p value of client with clientID
var g[NoOfClients]; // g[clientID] = g value of client with clientID

// Define random keys of server and client
var serverRandomKey[NoOfClients]; // serverRandomKey[clientID] = server random key (KS) corresponding to clientID
var clientRandomKey[NoOfClients]; // clientRandomKey[clientID] = client random key (KC) corresponding to clientID

// Define premaster keys of server and client
var serverPreMasterKey[NoOfClients]; // serverRandomKey[clientID] = server random key (KS) corresponding to clientID
var clientPreMasterKey[NoOfClients]; // clientRandomKey[clientID] = client random key (KC) corresponding to clientID

// Define messages sent by server and client
var serverMessage[NoOfClients]; // serverMessage[clientID] = server message (Ms) corresponding to clientID
var clientMessage[NoOfClients]; // clientMessage[clientID] = client message (Mc) corresponding to clientID

channel network 0;

var test = -2;
var randomClientMsg = 1234567;
var randomServerMsg = 1234;
var randomServerKey = 34567;
var randomClientKey = 191919;
var PremasterClientKey = 23232323;
var PremasterServerKey = 1231231232;


var debug;
var ServerCertificate;
var ServerCertificateSignature;



// Client processes
Client(clientID) =
	GenerateP{p[clientID] = clientID} -> // TODO: Change this
	GenerateG{g[clientID] = clientID} -> // TODO: CHange this
	network!clientID.clientID ->
	network!clientID.p[clientID] ->
	network!clientID.g[clientID] ->
	network?clientID.cipherVal ->
	network?clientID.serverMsg{test = serverMsg} ->
	ClientReceiveCert(clientID,serverMsg);
	
ClientReceiveCert(clientID,serverMsg) = 
	network?clientID.serverCert ->
	network?clientID.serverCertSignature ->
	ClientGeneratePreMaseter(clientID,serverMsg);

ClientGeneratePreMaseter(clientID,serverMsg) =
	GenerateClientRandomKey{clientRandomKey[clientID] = call(randomNumber)} -> // TODO: Generate random key
	GeneratePreMasterKey{clientPreMasterKey[clientID] = PremasterClientKey } ->  // TODO: Compute premaster key based on serverMsg
	network!clientID.clientRandomKey[clientID] -> 
	ClientConnected ->
	Skip;
	
	
Server() =
	network?x.clientID ->
	network?x.clientP ->
	network?x.clientG ->
	GenerateServerRandomKey{serverRandomKey[clientID] = call(randomNumber) } -> // TODO: Generate random server key
	GenerateServerMessage{serverMessage[clientID] = randomServerMsg} ->  // TODO: Compute  server message based on random key
	ServerHello(x,clientID);
	
ServerHello(x,clientID) =
	network!x.cipherSuite ->
	network!x.serverMessage[clientID] -> 
	ServerSendCert(x,clientID);
	
ServerSendCert(x,clientID) = 
	network!x.ServerCertificate ->
	network!x.ServerCertificateSignature ->
	ServerGeneratePreMaster(x,clientID);
	
ServerGeneratePreMaster(x,clientID) = 
	network?x.clientMessageReceived -> 
	GeneratePreMasterKey{serverPreMasterKey[clientID] = PremasterServerKey;debug = clientMessageReceived} -> // TODO: Compute server premasterkey based on clientMessageReceived
	ServerConnected -> 
	Stop;
	


	

TLS() = (||| clientID:{0..NoOfClients-1} @ Client(clientID)) ||| Server();

#assert TLS() deadlockfree;